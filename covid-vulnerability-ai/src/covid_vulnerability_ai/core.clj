; South African COVID-19 Vulnerability Map
;
; author: kogni7
; date: September 2022 / March 2023
;
; This program trains a regression model using scicloj for the South African COVID-19 Vulnerability Map competition on zindi.africa.
; The task is to predict the vulnerability to COVID-19 i.e. the percentage of households who have to leave the house for water.
; The structure of the project is:
; - src/covid_vulnerability_ai/core.clj  
; - project.clj
; - Data/
;   - data files
; - Submission/
;   - directories with the submission files
;
; Start the program within a terminal from the directory of project.clj with the command:
; lein run 


(ns covid_vulnerability_ai.core
  (:gen-class))

(require '[scicloj.ml.core :as ml]
         '[scicloj.ml.metamorph :as mm]
         '[scicloj.ml.dataset :as ds])

(defn -main [& args]
  
  ; Welcome!
  (println "\nWelcome! This program trains a regression model for the South African COVID-19 Vulnerability Map by #ZindiWeekendz competition on zindi.africa (https://zindi.africa/competitions/zindiweekendz-learning-south-african-covid-19-vulnerability-map)!")

  ; Preprocessing?
  (def possible-preprocessing '("no", "pca-cov", "pca-cor", "pca-prob", "kpca"))
  (println "Shall the data be preprocessed using dimension reduction methods?")
  (def counter 0)
  (doseq [preprocessing possible-preprocessing]
    (println (clojure.string/join [counter " for " preprocessing "."]))
    (def counter (+ counter 1)))
  (println "Please enter the number of the desired preprocessing: ")
  (def preprocessing (read-line))

  ; Model?
  (def possible-models '("Elastic Net", "Gradient Tree Boost", "Lasso", "Ordinary Least Square", "Random Forest", "Ridge Regression", "Linear Regression"))
  (println "Please choose a regression model for training: ")
  (def counter 0)
  (doseq [model possible-models]
    (println (clojure.string/join [counter " for " model "."]))
    (def counter (+ counter 1)))
  (println "Please enter the number of the desired model: ")
  (def chosen-model (read-line))

  ; Parameters?
  (cond
    ; Elastic Net
    (= (Integer/parseInt chosen-model) 0)
    (do
      (println "lambda1?")
      (def lambda1 (read-line))
      (println "lambda2?")
      (def lambda2 (read-line)))
    ; Gradient Tree Boost
    (= (Integer/parseInt chosen-model) 1)
    (do
      (println "trees?")
      (def trees (read-line)))
    ; Lasso
    (= (Integer/parseInt chosen-model) 2)
    (do
      (println "lambda?")
      (def lambda (read-line)))
    ; Ordinary Least Square: No parameters!
    ; Random Forest
    (= (Integer/parseInt chosen-model) 4)
    (do
      (println "trees?")
      (def trees (read-line)))
    ; Ridge Regression
    (= (Integer/parseInt chosen-model) 5)
    (do
      (println "lambda?")
      (def lambda (read-line)))
    ; Linear Regression
    (= (Integer/parseInt chosen-model) 6)
    (do
      (println "eta?")
      (def eta (read-line))))

  ; Cross-Validation?
  (println "On how many folds for cross-validation shall the model be trained? ")
  (def cv (read-line))

  (cond
    (= preprocessing 0) (println (clojure.string/join ["A " (nth possible-models (Integer/parseInt chosen-model)) " will be trained on " cv " folds."]))
    :else (println (clojure.string/join ["A " (nth possible-models (Integer/parseInt chosen-model)) " will be trained on " cv " folds using " (nth possible-preprocessing (Integer/parseInt preprocessing)) " for dimension reduction."])))
   
  ; Load data!
  (def train-data-frame
    (ds/dataset "Data/Train.csv" {:key-fn keyword}))
  (def test-data-frame
    (-> "Data/Test.csv" (ds/dataset {:key-fn keyword}) (ds/add-column :target_pct_vunerable [""] :cycle)))
  (def test-data-frame-ward-column
    (ds/select-columns (-> "Data/Test.csv" (ds/dataset {:key-fn keyword})) [:ward]))

  ; Prepare data!
  (defn prepare-data [data-frame]
    ; Reduce dimensions of dw, psa, lan, pg!
    (cond
      ; pca-cov
      (= (Integer/parseInt preprocessing) 1)
      (do
        (def pca :pca-cov)
        (def component-0 "pca-cov-0")
        (def component-1 "pca-cov-1")
        (def component-2 "pca-cov-2"))
      ; pca-cor   
      (= (Integer/parseInt preprocessing) 2)
      (do
        (def pca :pca-cor)
        (def component-0 "pca-cor-0")
        (def component-1 "pca-cor-1")
        (def component-2 "pca-cor-2"))
      ; pca-prob
      (= (Integer/parseInt preprocessing) 3)
      (do
        (def pca :pca-prob)
        (def component-0 "pca-prob-0")
        (def component-1 "pca-prob-1")
        (def component-2 "pca-prob-2"))
      ; kpca
      (= (Integer/parseInt preprocessing) 4)
      (do
        (def pca :kpca)
        (def component-0 "kpca-0")
        (def component-1 "kpca-1")
        (def component-2 "kpca-2")))

    (def pca-dw
      (ml/fit
       data-frame
       (mm/reduce-dimensions pca 3 [:dw_00 :dw_01 :dw_02 :dw_03 :dw_04 :dw_05 :dw_06 :dw_07 :dw_08 :dw_09 :dw_10 :dw_11] {})
       (mm/select-columns [:total_households :total_individuals component-0 component-1 component-2 :psa_00 :psa_01 :psa_02 :psa_03 :psa_04 :stv_00 :stv_01 :car_00 :car_01 :lln_00 :lln_01 :lan_00 :lan_01 :lan_02 :lan_03 :lan_04 :lan_05 :lan_06 :lan_07 :lan_08 :lan_09 :lan_10 :lan_11 :lan_12 :lan_14 :pg_00 :pg_01 :pg_02 :pg_03 :pg_04 :lgt_00 :target_pct_vunerable])))
    (def dw (ds/rename-columns (:metamorph/data pca-dw) [:total_households :total_individuals :dw_1 :dw_2 :dw_3 :psa_00 :psa_01 :psa_02 :psa_03 :psa_04 :stv_00 :stv_01 :car_00 :car_01 :lln_00 :lln_01 :lan_00 :lan_01 :lan_02 :lan_03 :lan_04 :lan_05 :lan_06 :lan_07 :lan_08 :lan_09 :lan_10 :lan_11 :lan_12 :lan_14 :pg_00 :pg_01 :pg_02 :pg_03 :pg_04 :lgt_00 :target_pct_vunerable]))
    (def pca-psa
      (ml/fit
       dw
       (mm/reduce-dimensions pca 2 [:psa_00 :psa_01 :psa_02 :psa_03 :psa_04] {})
       (mm/select-columns [:total_households :total_individuals :dw_1 :dw_2 :dw_3 component-0 component-1 :stv_00 :stv_01 :car_00 :car_01 :lln_00 :lln_01 :lan_00 :lan_01 :lan_02 :lan_03 :lan_04 :lan_05 :lan_06 :lan_07 :lan_08 :lan_09 :lan_10 :lan_11 :lan_12 :lan_14 :pg_00 :pg_01 :pg_02 :pg_03 :pg_04 :lgt_00 :target_pct_vunerable])))
    (def psa (ds/rename-columns (:metamorph/data pca-psa) [:total_households :total_individuals :dw_1 :dw_2 :dw_3 :psa_1 :psa_2 :stv_00 :stv_01 :car_00 :car_01 :lln_00 :lln_01 :lan_00 :lan_01 :lan_02 :lan_03 :lan_04 :lan_05 :lan_06 :lan_07 :lan_08 :lan_09 :lan_10 :lan_11 :lan_12 :lan_14 :pg_00 :pg_01 :pg_02 :pg_03 :pg_04 :lgt_00 :target_pct_vunerable]))
    (def pca-lan
      (ml/fit
       psa
       (mm/reduce-dimensions pca 3 [:lan_00 :lan_01 :lan_02 :lan_03 :lan_04 :lan_05 :lan_06 :lan_07 :lan_08 :lan_09 :lan_10 :lan_11 :lan_12 :lan_14] {})
       (mm/select-columns [:total_households :total_individuals :dw_1 :dw_2 :dw_3 :psa_1 :psa_2 :stv_00 :stv_01 :car_00 :car_01 :lln_00 :lln_01 component-0 component-1 component-2 :pg_00 :pg_01 :pg_02 :pg_03 :pg_04 :lgt_00 :target_pct_vunerable])))
    (def lan (ds/rename-columns (:metamorph/data pca-lan) [:total_households :total_individuals :dw_1 :dw_2 :dw_3 :psa_1 :psa_2 :stv_00 :stv_01 :car_00 :car_01 :lln_00 :lln_01 :lan_1 :lan_2 :lan_3 :pg_00 :pg_01 :pg_02 :pg_03 :pg_04 :lgt_00 :target_pct_vunerable]))
    (def pca-pg
      (ml/fit
       lan
       (mm/reduce-dimensions pca 2 [:pg_00 :pg_01 :pg_02 :pg_03 :pg_04] {})
       (mm/select-columns [:total_households :total_individuals :dw_1 :dw_2 :dw_3 :psa_1 :psa_2 :stv_00 :stv_01 :car_00 :car_01 :lln_00 :lln_01 :lan_1 :lan_2 :lan_3 component-0 component-1 :lgt_00 :target_pct_vunerable])))
    (ds/rename-columns (:metamorph/data pca-pg) [:total_households :total_individuals :dw_1 :dw_2 :dw_3 :psa_1 :psa_2 :stv_00 :stv_01 :car_00 :car_01 :lln_00 :lln_01 :lan_1 :lan_2 :lan_3 :pg_1 :pg_2 :lgt_00 :target_pct_vunerable]))

  (cond
    (not= (Integer/parseInt preprocessing) 0)
    (do
      (def train-data-frame (prepare-data train-data-frame))
      (def test-data-frame (prepare-data test-data-frame))))

  ; Train model!
  (def model-pipeline
    (ml/pipeline
     (cond
       ; dw_12 and dw_13 and lan_13 are constant and therefore not used
       (= (Integer/parseInt preprocessing) 0) (mm/select-columns [:total_households :total_individuals :dw_00 :dw_01 :dw_02 :dw_03 :dw_04 :dw_05 :dw_06 :dw_07 :dw_08 :dw_09 :dw_10 :dw_11 :psa_00 :psa_01 :psa_02 :psa_03 :psa_04 :stv_00 :stv_01 :car_00 :car_01 :lln_00 :lln_01 :lan_00 :lan_01 :lan_02 :lan_03 :lan_04 :lan_05 :lan_06 :lan_07 :lan_08 :lan_09 :lan_10 :lan_11 :lan_12 :lan_14 :pg_00 :pg_01 :pg_02 :pg_03 :pg_04 :lgt_00 :target_pct_vunerable])
       (not= (Integer/parseInt preprocessing) 0) (mm/select-columns [:total_households :total_individuals :dw_1 :dw_2 :dw_3 :psa_1 :psa_2 :stv_00 :stv_01 :car_00 :car_01 :lln_00 :lln_01 :lan_1 :lan_2 :lan_3 :pg_1 :pg_2 :lgt_00 :target_pct_vunerable]))
     (mm/set-inference-target :target_pct_vunerable)
     {:metamorph/id :model}
     (cond
       ; Elastic Net
       (= (Integer/parseInt chosen-model) 0) (mm/model {:model-type :smile.regression/elastic-net :lambda1 (Double/parseDouble lambda1) :lambda2 (Double/parseDouble lambda2)})
       ; Gradient Tree Boost
       (= (Integer/parseInt chosen-model) 1) (mm/model {:model-type :smile.regression/gradient-tree-boost :trees (Integer/parseInt trees)})
       ; Lasso
       (= (Integer/parseInt chosen-model) 2) (mm/model {:model-type :smile.regression/lasso :lambda (Double/parseDouble lambda)})
       ; Ordinary Least Square
       (= (Integer/parseInt chosen-model) 3) (mm/model {:model-type :smile.regression/ordinary-least-square})
       ; Random Forest
       (= (Integer/parseInt chosen-model) 4) (mm/model {:model-type :smile.regression/random-forest :trees (Integer/parseInt trees)})
       ; Ridge Regression
       (= (Integer/parseInt chosen-model) 5) (mm/model {:model-type :smile.regression/ridge :lambda (Double/parseDouble lambda)})
       ; Linear Regression
       (= (Integer/parseInt chosen-model) 6) (mm/model {:model-type :xgboost/linear-regression :eta (Double/parseDouble eta)}))))
  
  (def cross-validation
    (ds/split->seq train-data-frame :kfold {:k (Integer/parseInt cv) :seed 42}))
  (def pipes [model-pipeline])

  (def evaluation
    (ml/evaluate-pipelines pipes cross-validation ml/rmse :loss))
  (def best-context
    (-> evaluation first first :fit-ctx))
  (def best-pipe
    (-> evaluation first first :pipe-fn))

  (def model-for-prediction
    (best-pipe (assoc best-context :metamorph/data test-data-frame :metamorph/mode :transform)))
  
  (def prediction
    (model-for-prediction :metamorph/data :target_pct_vunerable))
  (def rmse
    (:metric (:test-transform (first (first evaluation)))))
  (cond
    ; Elastic Net
    (= (Integer/parseInt chosen-model) 0) (def settings (clojure.string/join ["\n## Settings:\n* nFolds: " cv "\n* lambda1: " lambda1 "\n* lambda2: " lambda2]))
    ; Gradient Tree Boost
    (= (Integer/parseInt chosen-model) 1) (def settings (clojure.string/join ["\n## Settings:\n* nFolds: " cv "\n* trees: " trees]))
    ; Lasso
    (= (Integer/parseInt chosen-model) 2) (def settings (clojure.string/join ["\n## Settings:\n* nFolds: " cv "\n* lambda: " lambda]))
    ; Ordinary Least Square
    (= (Integer/parseInt chosen-model) 3) (def settings (clojure.string/join ["\n## Settings:\n* nFolds: " cv]))
    ; Random Forest
    (= (Integer/parseInt chosen-model) 4) (def settings (clojure.string/join ["\n## Settings:\n* nFolds: " cv "\n* trees: " trees]))
    ; Ridge Regression
    (= (Integer/parseInt chosen-model) 5) (def settings (clojure.string/join ["\n## Settings:\n* nFolds: " cv "\n* lambda: " lambda]))
    ; Linear Regression
    (= (Integer/parseInt chosen-model) 6) (def settings (clojure.string/join ["\n## Settings:\n* nFolds: " cv "\n* eta: " eta])))
  
  (println "Experiment successful!")
 
  ; Make Submission!
  (def submission
    (ds/append test-data-frame-ward-column (ds/select-columns prediction [:target_pct_vunerable])))

  (def counter 1)
  (while (.exists (clojure.java.io/file (clojure.string/join ["Submission/" counter])))
    (do
      (def counter (+ counter 1))))

  (def output
    (clojure.string/join ["# Experiment Number " counter "\n## Preprocessing:\n" (nth possible-preprocessing (Integer/parseInt preprocessing)) "\n## Model:\n" (nth possible-models (Integer/parseInt chosen-model)) settings "\n## Results:\n* RMSE: " rmse]))
  
  (.mkdir (java.io.File. (clojure.string/join ["Submission/" counter])))
  (ds/write! submission (clojure.string/join ["Submission/" counter "/submission.csv"])) 
  (with-open [file (clojure.java.io/writer (clojure.string/join ["Submission/" counter "/output.md"]))] (.write file output))
  (println (clojure.string/join ["submission.csv and output.md are saved under Submission/" counter "."]))
  (System/exit 0)
)
